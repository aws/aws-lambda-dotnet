<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Amazon.Lambda.Annotations.SourceGenerator.Models" #>
<#@ import namespace="Amazon.Lambda.Annotations.SourceGenerator.Extensions" #>
<#@ import namespace="Amazon.Lambda.Annotations.SourceGenerator.Models.Attributes" #>
<#@ import namespace="Microsoft.CodeAnalysis" #>
<#@ import namespace="Amazon.Lambda.Annotations.SourceGenerator.Validation" #>
<#
    foreach (var ns in _model.GeneratedMethod.Usings)
    {
#>
using <#= ns #>;
<#
    }
#>

namespace <#= _model.LambdaMethod.ContainingNamespace #>
{
    public class <#= _model.GeneratedMethod.ContainingType.Name #>
    {
<#
    if (_model.LambdaMethod.UsingDependencyInjection)
    {
#>
        private readonly ServiceProvider serviceProvider;
<#
    }
    else
    {
#>
        private readonly <#= _model.LambdaMethod.ContainingType.Name #> <#= _model.LambdaMethod.ContainingType.Name.ToCamelCase() #>;
<#
    }
#>

        public <#= _model.GeneratedMethod.ContainingType.Name #>()
        {
<#
    if (_model.LambdaMethod.UsingDependencyInjection)
    {
#>
            var services = new ServiceCollection();

            // By default, Lambda function class is added to the service container using the singleton lifetime
            // To use a different lifetime, specify the lifetime in Startup.ConfigureServices(IServiceCollection) method.
            services.AddSingleton<<#= _model.LambdaMethod.ContainingType.Name #>>();

            var startup = new <#= _model.StartupType.FullName #>();
            startup.ConfigureServices(services);
            serviceProvider = services.BuildServiceProvider();
<#
    }
    else
    {
#>
            <#= _model.LambdaMethod.ContainingType.Name.ToCamelCase() #> = new <#= _model.LambdaMethod.ContainingType.Name #>();
<#
    }
#>
        }

        public <#= _model.LambdaMethod.IsAsync ? "async Task<" : "" #><#= _model.GeneratedMethod.ResponseType.Name #><#= _model.LambdaMethod.IsAsync ? ">" : "" #> <#= _model.LambdaMethod.Name #>(<#= _model.GeneratedMethod.RequestType.Name #> request, ILambdaContext context)
        {
<#
    if (_model.LambdaMethod.UsingDependencyInjection)
    {
#>
            // Create a scope for every request,
            // this allows creating scoped dependencies without creating a scope manually.
            using var scope = serviceProvider.CreateScope();
            var <#=
                _model.LambdaMethod.ContainingType.Name.ToCamelCase() #> = scope.ServiceProvider.GetRequiredService<<#= _model.LambdaMethod.ContainingType.Name #>>();

<#
    }

    if (_model.LambdaMethod.Events.Contains(EventType.API))
    {
        var parameters = string.Join(", ", _model.LambdaMethod.Parameters.Select(p => p.Name));
        var restApiAttribute = _model.LambdaMethod.Attributes.FirstOrDefault(att => att.Type.FullName == TypeFullNames.RestApiAttribute) as AttributeModel<RestApiAttribute>;
        var httpApiAttribute = _model.LambdaMethod.Attributes.FirstOrDefault(att => att.Type.FullName == TypeFullNames.HttpApiAttribute) as AttributeModel<HttpApiAttribute>;

        if (restApiAttribute != null && httpApiAttribute != null)
        {
            throw new NotSupportedException($"A method cannot have both {TypeFullNames.RestApiAttribute} and {TypeFullNames.HttpApiAttribute} attribute at the same time.");
        }

        var routeParameters = restApiAttribute?.Data?.GetTemplateParameters() ?? httpApiAttribute?.Data?.GetTemplateParameters() ?? new HashSet<string>();

        var (routeTemplateValid, missingRouteParams) = RouteParametersValidator.Validate(routeParameters, _model.LambdaMethod.Parameters);
        if (!routeTemplateValid)
        {
            var template = restApiAttribute?.Data?.Template ?? httpApiAttribute?.Data?.Template ?? string.Empty;
            throw new InvalidOperationException($"Route template {template} is invalid. Missing {string.Join(",", missingRouteParams)} parameters in method definition.");
        }

        foreach (var parameter in _model.LambdaMethod.Parameters)
        {
            if (parameter.Attributes.Any(att => att.Type.FullName == TypeFullNames.FromServiceAttribute))
            {
#>
            var <#= parameter.Name #> = scope.ServiceProvider.GetRequiredService<<#= parameter.Type.FullName #>>();
<#
            }
            else if (parameter.Attributes.Any(att => att.Type.FullName == TypeFullNames.FromQueryAttribute))
            {
                var fromQueryAttribute = parameter.Attributes.First(att => att.Type.FullName == TypeFullNames.FromQueryAttribute) as AttributeModel<FromQueryAttribute>;

                // Use parameter name as key, if Name has not specified explicitly in the attribute definition.
                var parameterKey = fromQueryAttribute?.Data?.Name ?? parameter.Name;

                var queryStringParameters = "QueryStringParameters";

#>
            var <#= parameter.Name #> = default(<#= parameter.Type.FullName #>);
<#

                if (parameter.Type.IsEnumerable && parameter.Type.IsGenericType)
                {
                    // In HTTP API V2 multiple values for the same parameter are represented via comma separated string
                    // Therefore, it is required to split the string to convert to an enumerable
                    // and convert individual item to target data type.
                    var commaSplit = "";
                    if (httpApiAttribute?.Data.Version == HttpApiVersion.V2)
                    {
                        commaSplit = @".Split("","")";
                    }

                    // HTTP API V1 and Rest API, multiple values for the same parameter are provided
                    // dedicated dictionary of string key and list value.
                    if (restApiAttribute != null || httpApiAttribute?.Data.Version == HttpApiVersion.V1)
                    {
                        queryStringParameters = "MultiValueQueryStringParameters";
                    }

                    if (parameter.Type.TypeArguments.Count != 1)
                    {
                        throw new NotSupportedException("Only one type argument is supported for generic types.");
                    }

                    // Generic types are mapped using Select statement to the target parameter type argument.
                    var typeArgument = parameter.Type.TypeArguments.First();
                    var select = $".Select(q => ({typeArgument.FullName})Convert.ChangeType(q, typeof({typeArgument.FullName}))).ToList()";
#>
            if (request.<#= queryStringParameters #>?.ContainsKey("<#= parameterKey #>") == true)
            {
                <#= parameter.Name #> = request.<#= queryStringParameters #>["<#= parameterKey #>"]<#= commaSplit #><#= select #>;
            }

<#
                }
                else
                {
                    // Non-generic types are mapped directly to the target parameter.
#>
            if (request.<#= queryStringParameters #>?.ContainsKey("<#= parameterKey #>") == true)
            {
                <#= parameter.Name #> = (<#= parameter.Type.FullName #>)Convert.ChangeType(request.<#= queryStringParameters #>["<#= parameterKey #>"], typeof(<#= parameter.Type.FullName #>));
            }

<#
                }

            }
            else if (parameter.Attributes.Any(att => att.Type.FullName == TypeFullNames.FromHeaderAttribute))
            {
                var fromHeaderAttribute =
                    parameter.Attributes.First(att => att.Type.FullName == TypeFullNames.FromHeaderAttribute) as
                        AttributeModel<FromHeaderAttribute>;

                // Use parameter name as key, if Name has not specified explicitly in the attribute definition.
                var headerKey = fromHeaderAttribute?.Data?.Name ?? parameter.Name;

                var headers = "Headers";

#>
            var <#= parameter.Name #> = default(<#= parameter.Type.FullName #>);
<#

                if (parameter.Type.IsEnumerable && parameter.Type.IsGenericType)
                {
                    // In HTTP API V2 multiple values for the same header are represented via comma separated string
                    // Therefore, it is required to split the string to convert to an enumerable
                    // and convert individual item to target data type.
                    var commaSplit = "";
                    if (httpApiAttribute?.Data.Version == HttpApiVersion.V2)
                    {
                        commaSplit = @".Split("","")";
                    }

                    // HTTP API V1 and Rest API, multiple values for the same header are provided
                    // dedicated dictionary of string key and list value.
                    if (restApiAttribute != null || httpApiAttribute?.Data.Version == HttpApiVersion.V1)
                    {
                        headers = "MultiValueHeaders";
                    }

                    if (parameter.Type.TypeArguments.Count != 1)
                    {
                        throw new NotSupportedException("Only one type argument is supported for generic types.");
                    }

                    // Generic types are mapped using Select statement to the target parameter type argument.
                    var typeArgument = parameter.Type.TypeArguments.First();
                    var select =
                        $".Select(q => ({typeArgument.FullName})Convert.ChangeType(q, typeof({typeArgument.FullName}))).ToList()";
#>
            if (request.<#= headers #>?.ContainsKey("<#= headerKey #>") == true)
            {
                <#= parameter.Name #> = request.<#= headers #>["<#= headerKey #>"]<#= commaSplit #><#= select #>;
            }

<#
                }
                else
                {
                    // Non-generic types are mapped directly to the target parameter.
#>
            if (request.<#= headers #>?.ContainsKey("<#= headerKey #>") == true)
            {
                <#= parameter.Name #> = (<#= parameter.Type.FullName #>)Convert.ChangeType(request.<#= headers #>["<#= headerKey #>"], typeof(<#= parameter.Type.FullName #>));
            }

<#
                }
            }
            else if (parameter.Attributes.Any(att => att.Type.FullName == TypeFullNames.FromBodyAttribute))
            {
                // string parameter does not need to be de-serialized
                if (parameter.Type.IsString())
                {
 #>
            var <#= parameter.Name #> = request.Body;

<#
                }
                else
                {
 #>
            var <#= parameter.Name #> = <#= _model.Serializer #>.Deserialize<<#= parameter.Type.FullName #>>(request.Body);

<#
                }
            }
            else if (parameter.Attributes.Any(att => att.Type.FullName == TypeFullNames.FromRouteAttribute) || routeParameters.Contains(parameter.Name))
            {
                var fromRouteAttribute = parameter.Attributes?.FirstOrDefault(att => att.Type.FullName == TypeFullNames.FromRouteAttribute) as AttributeModel<FromRouteAttribute>;

                // Use parameter name as key, if Name has not specified explicitly in the attribute definition.
                var routeKey = fromRouteAttribute?.Data?.Name ?? parameter.Name;
#>
            var <#= parameter.Name #> = default(<#= parameter.Type.FullName #>);
            if (request.PathParameters?.ContainsKey("<#= routeKey #>") == true)
            {
                <#= parameter.Name #> = (<#= parameter.Type.FullName #>)Convert.ChangeType(request.PathParameters["<#= routeKey #>"], typeof(<#= parameter.Type.FullName #>));
            }

<#
            }
            else
            {
                throw new NotSupportedException($"{parameter.Name} parameter of type {parameter.Type.FullName} passing is not supported.");
            }
        }

        if (_model.LambdaMethod.ReturnsVoidOrTask)
        {
#>
            <#= _model.LambdaMethod.IsAsync ? "await " : "" #><#= _model.LambdaMethod.ContainingType.Name.ToCamelCase() #>.<#= _model.LambdaMethod.Name #>(<#= parameters #>);
<#
        }
        else
        {
#>
            var response = <#= _model.LambdaMethod.IsAsync ? "await " : "" #><#= _model.LambdaMethod.ContainingType.Name.ToCamelCase() #>.<#= _model.LambdaMethod.Name #>(<#= parameters #>);
<#
        }

        if (_model.GeneratedMethod.ResponseType.FullName == _model.LambdaMethod.ReturnType.FullName)
        {
#>
            return response;
<#
        }
        else
        {
            if (!_model.LambdaMethod.ReturnsVoidOrTask)
            {
                if (_model.LambdaMethod.ReturnType.IsValueType)
                {
#>

            var body = response.ToString();
<#
                }
                else if (_model.LambdaMethod.ReturnType.IsString())
                {
                    // no action
                }
                else
                {
#>

            var body = <#= _model.Serializer #>.Serialize(response);
<#
                }
            }
#>

            return new <#= _model.GeneratedMethod.ResponseType.Name #>
            {
<#
            if (!_model.LambdaMethod.ReturnsVoidOrTask)
            {
#>
                Body = <#= _model.LambdaMethod.ReturnType.IsString() ? "response" : "body" #>,
                Headers = new Dictionary<string, string>
                {
                    {"Content-Type", <#= _model.LambdaMethod.ReturnType.IsString() ? "\"text/plain\"" : "\"application/json\"" #>}
                },
<#
            }
#>
                StatusCode = 200
            };
<#
        }
    }
#>
        }
    }
}